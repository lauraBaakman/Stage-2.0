%!TEX root = paper.tex

%General Idea
	We use shape adaptive kernels in combination with the Modified Breiman Estimator introduced by \textcite{wilkinson1995dataplot} 
	%General bandwidth
	with the general bandwidths computed according to the method introduced by \textcite{ferdosi2011comparison} for its lower computational complexity.
	%Pilot Densities
	The pilot densities are computed on a $20 \times \cdots \times 20$ grid that covers all data points.
	%Local bandwidths
	We have empirically determined \todo{hoe hebben we dat vastgesteld} that using \varMBESensitivityParam = \todo{Een of andere waarde} works best in our case. 
	%Final densities
	The final density estimated is estimated with an Epanechnikov kernel according to:
	\begin{equation}\label{eq:2:parzenWithBandWidthMatrix}
		\varEstimatedDensityFunction{\varPattern} = \frac{1}{\varNumPatterns}\sum_{\itXis = 1}^{\varNumPatterns} \frac{1}{\det\left(\varLocalBandwidth{\itXis} \cdot \varBandwidthMatrix\right)}\varKernel{\left(\varLocalBandwidth{\itXis} \cdot \varBandwidthMatrix\right)^{-1}\left(\varPattern - \varPattern[\itXis]\right)}.
	\end{equation}
	The shape of the kernel \varKernel{\bullet} is determined by the bandwidth matrix \varBandwidthMatrix. If a fixed width method is used $\varLocalBandwidth{\itXis} = 1$. \Cref{eq:2:parzenWithBandWidthMatrix} reduces to the fixed-width Parzen estimator defined in \cref{eq:1:parzen}, if $\varBandwidthMatrix = \varBandwidth \cdot \identityMatrix{\varDim}$.
	
	For each data point \varPattern of which the density is estimated the bandwidth matrix is determined according to these steps:
		\begin{enumerate}[labelindent=0ex]
			\item \label{it:1:bandwidthmatrix:findNeighbours}
				Find \varNeighborhood{\varPattern}, the \KNNK-nearest neighbors of \varPattern.
			\item \label{it:1:bandwidthmatrix:initialBandwidthMatrix}
				Compute \varCovarianceMatrix, the unbiased covariance matrix of the local neighborhood \varNeighborhood{\varPattern}.
			\item \label{it:1:bandwidthmatrix:scaleBandwidhtMatrix}
				Determine \varBandwidthMatrix by scaling \varCovarianceMatrix with
				\begin{equation}\label{eq:method:scalingFactor}
					\varScalingFactor = \varBandwidth \left( \displaystyle\prod_{\itDim = 1}^{\varDim} \varEigenValue_\itDim \right)^{-\frac{1}{\varDim}}
				\end{equation}
				where $\varEigenValue_1,\, \cdots,\, \varEigenValue_\varDim$ are the eigenvalues of \varCovarianceMatrix.  
		\end{enumerate}	
	% Discuss step 1
			% Why do we use KNN instead of fixed-radius
			Step \ref{it:1:bandwidthmatrix:findNeighbours} determines the local neighborhood of \varPattern with the \KNNK nearest neighbors algorithm (\KNN) with Euclidean distance. We use this approach rather than a fixed-radius neighborhood to ensure that, independent of the sparsity of the data, the kernel shape is always based on a reasonable number of data points. 
			% How do we choose K
			We follow \citeauthor{silverman1986density}'s \cite{silverman1986density} recommendation of choosing $k = \sqrt{\varNumPatterns}$. To ensure that \varCovarianceMatrix is nonsingular we also need $\KNNK > \varDim$, therefore
			\begin{equation*}
				\KNNK = \max\left(\left\lfloor \sqrt{\varNumPatterns} \right\rceil,\, \varDim \right) + 1.	
			\end{equation*}
		%  Discuss step 2
			Step \ref{it:1:bandwidthmatrix:initialBandwidthMatrix} determines the basic shape of the bandwidth covariance matrix. 

		% 	Discuss step 3
			Step \ref{it:1:bandwidthmatrix:scaleBandwidhtMatrix} ensures that the kernels used in the density estimation of different patterns have the same domain, modulo the local bandwidths. \Cref{eq:method:scalingFactor} scales the bandwidth matrix in such a way that the volume of the ellipsoid defined by the eigenvectors and values of \varBandwidthMatrix is equal to that of the eigenellipsoid of the bandwidth matrix that is implicitly used in \cref{eq:1:parzen}.